#include <Arduino.h>
// #include <Esp.h>
#include "BLEDevice.h"


#define bleServerName "LARS_Bracelet"
#define LED_RESOLUTION 10
#define LED_FREQ       1
#define LED_1_CH       0
#define LED_2_CH       1
#define LED_1          GPIO_NUM_18 // red
#define LED_2          GPIO_NUM_32 // green


static bool doConnect = false; // переменная, используемая для определения того, нужно ли начинать подключение или завершено ли подключение
volatile bool connected = false;

static BLEUUID bleServiceUUID("6E400001-B5A3-F393-E0A9-E50E24DCCA9E"); // UUID сервиса
static BLEUUID bleStringCharacteristicUUID("6E400003-B5A3-F393-E0A9-E50E24DCCA9E"); // UUID для (данные одной строчки)
static BLEAddress* pServerAddress; // адрес периферийного устройства (он должен быть найден во время сканирования)
static BLERemoteCharacteristic* bleStringCharacteristic; // характеристики, данные которых необходимо считать
BLEClient* pClient = BLEDevice::createClient();
static BLEAdvertisedDevice* bracelet_server;


class ClientCallback : public BLEClientCallbacks {
    void onConnect(BLEClient* pclient) {}

    void onDisconnect(BLEClient* pclient) {
        // esp_restart();
        connected = false;
    }
};

class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
    /** @brief Метод обратного вызова, который будет вызван при получении оповещения от другого устройства
     */
    void onResult(BLEAdvertisedDevice advertisedDevice) {
        if (advertisedDevice.getName() == bleServerName) {
            connected = true;
            // advertisedDevice.getScan()->stop(); // остановка сканирования после совпадения имен
            BLEDevice::getScan()->stop();
            bracelet_server = new BLEAdvertisedDevice(advertisedDevice);
            pServerAddress = new BLEAddress(advertisedDevice.getAddress()); // сохраняем адрес устройства, рассылающего оповещения
            doConnect = true; // задаем индикатор, дающий понять, что мы готовы подключиться
            Serial.println("Device is found. Connecting!");
        }
    }
};

typedef struct {
    uint8_t idx;
    int16_t a_x;
    int16_t a_y;
} imu_data_5B_s;

typedef struct {
    uint8_t idx;
    int16_t a_x;
    int16_t a_y;
    int16_t a_z;
    int16_t w_x;
    int16_t w_y;
    int16_t w_z;
} imu_data_13B_s;


static void bleStringNotifyCallback(BLERemoteCharacteristic* pBLERemoteCharacteristic, uint8_t* pData, size_t length, bool isNotify) {
    /*switch ((*pData) & 0xFE) {
        case 0x50: // info about charge
            Serial.print(*pData); // device id + message id
            Serial.print(',');
            Serial.print(*(++pData)); // value
            Serial.println(',');
            break;
        case 0x90: {// info about buttons and gestures
                uint8_t gesture_buttons = *(++pData);
                Serial.print(gesture_buttons & 0x01); Serial.print(',');
                Serial.print(gesture_buttons & 0x02); Serial.print(',');
                Serial.print(gesture_buttons & 0x04); Serial.println(',');
            }
            break;
        case 0x30: {// for only two accelerations
                imu_data_5B_s tmp_struct;
                memcpy(&tmp_struct, pData, sizeof(tmp_struct));
                Serial.print(tmp_struct.idx); Serial.print(',');
                Serial.print(tmp_struct.a_x); Serial.print(',');
                Serial.print(tmp_struct.a_y); Serial.println(',');
            }
            break;
        case 0x34: {// for all mpu data
                imu_data_13B_s tmp_struct;
                memcpy(&tmp_struct, pData, sizeof(tmp_struct));
                Serial.print(tmp_struct.idx); Serial.print(',');
                Serial.print(tmp_struct.a_x); Serial.print(',');
                Serial.print(tmp_struct.a_y); Serial.print(',');
                Serial.print(tmp_struct.a_z); Serial.print(',');
                Serial.print(tmp_struct.w_x); Serial.print(',');
                Serial.print(tmp_struct.w_y); Serial.print(',');
                Serial.print(tmp_struct.w_z); Serial.println(',');
            }
    }*/

    char tmp[50];
    memset(tmp, 0, sizeof(tmp));
    memcpy(tmp, pData, length);
    Serial.print(tmp);
}

/**
 * @brief Подключение к BLE-серверу
 * @retval Статус подключения
 */
bool connectToServer(BLEAddress pAddress) {
    pClient->setClientCallbacks(new ClientCallback()); /****************************/

    // pClient->connect(pAddress);
    // if (pClient->connect(pAddress, BLE_ADDR_TYPE_PUBLIC)) { // подключаемся к удаленному BLE-серверу
    pClient->connect(bracelet_server);
    BLERemoteService* pRemoteService = pClient->getService(bleServiceUUID); // считываем UUID искомого сервиса

    if (pRemoteService == nullptr) {
        return false;
    }

    bleStringCharacteristic = pRemoteService->getCharacteristic(bleStringCharacteristicUUID); // считываем UUID искомых характеристик

    if (bleStringCharacteristic == nullptr) {
        Serial.print("Failed to find our characteristic UUID");
        return false;
    }

    // Serial.println(" - Сharacteristics were found");
    bleStringCharacteristic->registerForNotify(bleStringNotifyCallback);
    return true;
}


void setup() {
    Serial.begin(115200);
    // setCpuFrequencyMhz(80);

    ledcSetup(LED_1_CH, LED_FREQ, LED_RESOLUTION);
    ledcSetup(LED_2_CH, LED_FREQ, LED_RESOLUTION);

    ledcAttachPin(LED_1, LED_1_CH);
    ledcAttachPin(LED_2, LED_2_CH);
    ledcWrite(LED_1_CH, 240);
    ledcWrite(LED_2_CH, 512);

    // инициализируем BLE-устройство
    BLEDevice::init("ESP32_Client");
    // BLEDevice::setCustomGapHandler(my_gap_event_handler);
    // BLEDevice::setCustomGattcHandler(my_gattc_event_handler);

    // BLEAddress address("ef:05:04:79:49:bf"); // ef:05:04:79:49:bf - black, d8:c5:de:83:0f:db - white, C7:BE:5C:22:12:97
    // while (!connectToServer(address));/****************************************************/
    // pClient->connect(address, BLE_ADDR_TYPE_PUBLIC);
    /* Setting the new tx power */
    if (esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_SCAN, ESP_PWR_LVL_P9) == ESP_FAIL) {
        Serial.println("Tx power set failed");
    }

    // tim_conn_check = timerBegin(0, 80, true);
    // timerAttachInterrupt(tim_conn_check, &tim_check_handle, true);
    // timerAlarmWrite(tim_conn_check, 1000000, true);

    // создаем экземпляр класса «BLEScan» для сканирования
    // и задаем для этого объекта функцию обратного вызова,
    // которая будет информировать о том, найдено ли новое устройство;
    // дополнительно указываем, что нам нужно активное сканирование,
    // а потом запускаем 30-секундное сканирование:
    BLEScan* pBLEScan = BLEDevice::getScan();
    pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
    pBLEScan->setActiveScan(true);
    pBLEScan->setInterval(100);
    pBLEScan->setWindow(99);
    pBLEScan->start(5, false);
}


void loop() {
    if (doConnect) {
        if (connectToServer(*pServerAddress)) { // подключение к серверу
            // timerWrite(tim_conn_check, 0);
            // timerAlarmEnable(tim_conn_check);          
            ledcWrite(LED_2_CH, 1024);
            ledcWrite(LED_1_CH, 0);
        } else {
            Serial.println("We have failed to connect to the server; Restart your device to scan for nearby BLE server again.");
            //  "Подключиться к серверу не получилось.
            ledcWrite(LED_1_CH, 160);
            ledcWrite(LED_2_CH, 160);
        }
        doConnect = false;
    } else if (!connected) {
        BLEDevice::getScan()->start(0);
    }

    // if (tim_check_flag) {
    //     if (!pClient->isConnected()) {
    //         esp_restart();
    //     }
    //     tim_check_flag = false;
    // }
    

}
